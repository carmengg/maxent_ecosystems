---
title: "Observation and Environmental Data Preparation"
author: "Carmen Galaz-Garc√≠a"
date: "1/4/2022"
output: html_document
---

```{r setup, include=FALSE}
# load packages, installing if missing
if (!require(librarian)){
  install.packages("librarian")
  library(librarian)
}

librarian::shelf(
  dismo, 
  dplyr, 
  DT, 
  ggplot2, 
  here, 
  htmltools, 
  leaflet, 
  mapview, 
  purrr, 
  readr, 
  rgbif, 
  rgdal, 
  raster,
  rJava, 
  sdmpredictors, 
  sf, 
  spocc, 
  tidyr)

select <- dplyr::select # overwrite raster::select

# set random seed for reproducibility
set.seed(42)

# directory to store data
data_dir <- here("jaguars/jaguars_data")
dir.create(data_dir, showWarnings = F, recursive = TRUE)

```

## Access, clean and export GBIF jaguar observations

```{r}
redo <- TRUE

# path for observations data as csv
obs_csv <- file.path(data_dir, "jaguars_obs.csv")
# path for observations data as coordinates (geojson)
obs_geo <- file.path(data_dir, "jaguars_obs.geojson")


if (!file.exists(obs_geo) | redo){
  # GET GBIF DATA
  (res <- spocc::occ(
    query = 'Panthera onca', # jaguar
    from = 'gbif', 
    limit = 10000, # initially recovered 3362 records
    has_coords = T))
# -----------------------------------------------------------------------------  
  # CLEAN DATA
  df <- res$gbif$data[[1]] %>% 
    # some columns were type list, only kept those with data we will use
    select(longitude, latitude, prov, key) %>% 
    # remove non-terrestrial sights (removed 324 records)
    # https://data-blog.gbif.org/post/gbif-filtering-guide/
    CoordinateCleaner::cc_sea(lon = "longitude", lat = "latitude")
    rm(res)
# -----------------------------------------------------------------------------    
  # EXPORT OBSERVATIONS AS CSV
  readr::write_csv(df, obs_csv)
# -----------------------------------------------------------------------------  
  # EXPORT OBSERVATIONS AS GEOJSON
  # convert to points of observation from lon/lat columns in data frame
  obs <- df %>% 
    sf::st_as_sf(
      coords = c("longitude", "latitude"),
      crs = st_crs(4326))  
  # export coordinates of observations
  sf::write_sf(obs, obs_geo, delete_dsn=T)
}

obs <- sf::read_sf(obs_geo)
nrow(obs) 
rm(df,obs_csv,obs_geo)
```


```{r}
# show points on map
mapview::mapview(obs, map.types = "Stamen.Terrain")
```

## Access, subset and export Species Distribution Modeling Predictor Datasets

### Explore available datasets
```{r}
# path for environmental data, will save rasters of env variables here
dir_env <- file.path(data_dir, "env")
# set a default data directory **** ?? Not needed?
options(sdmpredictors_datadir = dir_env) 

# choosing terrestrial
env_datasets <- sdmpredictors::list_datasets(terrestrial = TRUE, marine = FALSE)

# show table of datasets
env_datasets %>% 
  select(dataset_code, description, citation) %>% 
  DT::datatable()
```

```{r}
# choose datasets
env_datasets_vec <- c("WorldClim", "ENVIREM")

# get layers
env_layers <- sdmpredictors::list_layers(env_datasets_vec)
DT::datatable(env_layers)
rm(env_datasets_vec,env_layers)
```

### Dataset selection

```{r}
# choose layers after some inspection and perhaps consulting literature
env_layers_vec <- c("WC_alt", # altitude
                    "WC_bio1", # Annual mean temperature
                    "WC_bio2", # Mean diurnal temperature range
                    "WC_bio13", # Precipitation of wettest month
                    "WC_bio14", # Precipitation of driest month
                    "WC_bio15", # Precipitation seasonality
                    #"ER_aridityIndexThornthwaite", #T hornthwaite aridity index
                    "ER_tri", # Terrain roughness index
                    "ER_topoWet") # Topographic wetness

# get layers
env_stack <- load_layers(env_layers_vec)
rm(env_layers_vec)

# interactive plot layers, hiding all but first (select others)
# mapview(env_stack, hide = T) # makes the html too big for Github
plot(env_stack, nc=2)
```

### Mask environmental variables with observations convex hull

```{r}
# -----------------------------------------------------------------------------
# OBTAIN CONVEX HULL
# path for the shapefile of the observations convex hull

save_ch <- FALSE
# make convex hull around points of observation
obs_hull <- sf::st_convex_hull(st_union(obs))

if (save_ch){
  obs_hull_geo  <- file.path(data_dir, "obs_hull.geojson")
  write_sf(obs_hull, obs_hull_geo)
  obs_hull <- read_sf(obs_hull_geo)
  rm(obs_hull_geo)
}
rm(write_ch, save_ch)

# show observations + CH on map
mapview(list(obs, obs_hull))
```


```{r}
# -----------------------------------------------------------------------------
# MASK ENV VARIABLES STACK 
save_env_stack <- TRUE

obs_hull_sp <- sf::as_Spatial(obs_hull)
env_stack <- raster::mask(env_stack, obs_hull_sp) %>% 
    raster::crop(extent(obs_hull_sp))

if (save_env_stack){
  env_stack_grd <- file.path(data_dir, "env_stack.grd")
  writeRaster(env_stack, env_stack_grd, overwrite=T)  
  env_stack <- stack(env_stack_grd)
  rm(env_stack_grd)
}
rm(obs_hull_sp,save_env_stack)


plot(env_stack, nc=2)
```


## Generating Pseudo Absences

```{r}
# path for coordinates of absence data
save_absences <- FALSE
# -----------------------------------------------------------------------------
# create raster from observatins: cell value = # observations in cell
obs_raster <- rasterize(
  sf::as_Spatial(obs), env_stack[[1]], field=1, fun='count')
# show map
#mapview(obs) + mapview(obs_raster)
# -----------------------------------------------------------------------------
# mask all the points outside the observations
r_mask <- mask(env_stack[[1]] > -Inf, obs_raster, inverse=T)
# -----------------------------------------------------------------------------
# generate random points inside mask
absence <- dismo::randomPoints(r_mask, nrow(obs)) %>% 
  as_tibble() %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326)

rm(r_mask,obs_raster)
# -----------------------------------------------------------------------------
if (save_absences){
  absence_geo <- file.path(data_dir, "absence.geojson")
  write_sf(absence, absence_geo, delete_dsn=T)
  absence <- read_sf(absence_geo)
  rm(absence_geo)
}
rm(save_absences)

# -----------------------------------------------------------------------------
# show map of presence, ie obs, and absence
mapview(obs, col.regions = "green") + 
  mapview(absence, col.regions = "gray")
```


## Combining presence and absences

```{r}
save_pres_abs <- TRUE

# -----------------------------------------------------------------------------
# combine presence and absence into single set of labeled points 
pts <- rbind(
  obs %>% 
    mutate(
      present = 1) %>% 
    select(present, key),
  absence %>% 
    mutate(
      present = 0,
      key     = NA)) %>% 
  mutate(
    ID = 1:n()) %>% 
  relocate(ID)

# -----------------------------------------------------------------------------
# extract environmental values from rasters for absence/observation coordinates
pts_env <- raster::extract(env_stack, as_Spatial(pts), df=TRUE) %>% 
  tibble() %>% 
  # join present and geometry columns to raster value results for points
  left_join(
    pts %>% 
      select(ID, present),
    by = "ID") %>% 
  relocate(present, .after = ID) %>% 
  # extract lon, lat as single columns
  mutate(
    #present = factor(present),
    lon = st_coordinates(geometry)[,1],
    lat = st_coordinates(geometry)[,2]) %>% 
  select(-geometry)

# -----------------------------------------------------------------------------
if (save_pres_abs){
  # coordinates of all data (observations and absences)
  pts_geo     <- file.path(data_dir, "pts.geojson")
  write_sf(pts, pts_geo, delete_dsn=T)
  
  # path for all data: env predictors and presence/absence data
  pts_env_csv <- file.path(data_dir, "pts_env.csv")
  write_csv(pts_env, pts_env_csv)
  pts_env <- read_csv(pts_env_csv)
  rm(pts_env_csv,pts_geo)
}
rm(save_pres_abs)

# -----------------------------------------------------------------------------
pts_env %>% 
  # show first 10 presence, last 10 absence
  slice(c(1:10, (nrow(pts_env)-9):nrow(pts_env))) %>% 
  DT::datatable(
    rownames = F,
    options = list(
      dom = "t",
      pageLength = 20))
```

